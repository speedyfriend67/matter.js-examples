<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Double Pendulum</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <canvas id="engineCanvas" width="800" height="600"></canvas>
    
    <div id="controls">
        <label for="gravityScale">Gravity Scale:</label>
        <input type="number" id="gravityScale" value="0.002">
        <br>
        <label for="stiffness">Stiffness:</label>
        <input type="number" id="stiffness" value="0.9">
        <br>
        <label for="angularStiffness">Angular Stiffness:</label>
        <input type="number" id="angularStiffness" value="0.7">
        <br>
        <label for="armRotation">Arm Rotation:</label>
        <input type="number" id="armRotation" value="-0.3">
        <br>
        <button onclick="updatePendulum()">Update Pendulum</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
    <script>
        var Example = Example || {};

        Example.doublePendulum = function() {
            var Engine = Matter.Engine,
                Events = Matter.Events,
                Render = Matter.Render,
                Runner = Matter.Runner,
                Body = Matter.Body,
                Composite = Matter.Composite,
                Composites = Matter.Composites,
                Constraint = Matter.Constraint,
                MouseConstraint = Matter.MouseConstraint,
                Mouse = Matter.Mouse,
                Bodies = Matter.Bodies,
                Vector = Matter.Vector;

            // create engine
            var engine = Engine.create(),
                world = engine.world;

            // create renderer
            var render = Render.create({
                element: document.body,
                engine: engine,
                options: {
                    width: 800,
                    height: 600,
                    wireframes: false
                }
            });

            Render.run(render);

            // create runner
            var runner = Runner.create();
            Runner.run(runner, engine);

            // add bodies
            var group = Body.nextGroup(true),
                length = 200,
                width = 25;

            var pendulum = Composites.stack(350, 160, 2, 1, -20, 0, function(x, y) {
                return Bodies.rectangle(x, y, length, width, { 
                    collisionFilter: { group: group },
                    frictionAir: 0,
                    chamfer: 5,
                    render: {
                        fillStyle: 'transparent',
                        lineWidth: 1
                    }
                });
            });

            engine.gravity.scale = 0.002;

            Composites.chain(pendulum, 0.45, 0, -0.45, 0, { 
                stiffness: 0.9, 
                length: 0,
                angularStiffness: 0.7,
                render: {
                    strokeStyle: '#4a485b'
                }
            });

            Composite.add(pendulum, Constraint.create({ 
                bodyB: pendulum.bodies[0],
                pointB: { x: -length * 0.42, y: 0 },
                pointA: { x: pendulum.bodies[0].position.x - length * 0.42, y: pendulum.bodies[0].position.y },
                stiffness: 0.9,
                length: 0,
                render: {
                    strokeStyle: '#4a485b'
                }
            }));

            var lowerArm = pendulum.bodies[1];

            Body.rotate(lowerArm, -Math.PI * 0.3, {
                x: lowerArm.position.x - 100,
                y: lowerArm.position.y
            });

            Composite.add(world, pendulum);

            var trail = [];

            Events.on(render, 'afterRender', function() {
                trail.unshift({
                    position: Vector.clone(lowerArm.position),
                    speed: lowerArm.speed
                });

                Render.startViewTransform(render);
                render.context.globalAlpha = 0.7;

                for (var i = 0; i < trail.length; i += 1) {
                    var point = trail[i].position,
                        speed = trail[i].speed;

                    var hue = 250 + Math.round((1 - Math.min(1, speed / 10)) * 170);
                    render.context.fillStyle = 'hsl(' + hue + ', 100%, 55%)';
                    render.context.fillRect(point.x, point.y, 2, 2);
                }

                render.context.globalAlpha = 1;
                Render.endViewTransform(render);

                if (trail.length > 2000) {
                    trail.pop();
                }
            });

            // add mouse control
            var mouse = Mouse.create(render.canvas),
                mouseConstraint = MouseConstraint.create(engine, {
                    mouse: mouse,
                    constraint: {
                        stiffness: 0.2,
                        render: {
                            visible: false
                        }
                    }
                });

            Composite.add(world, mouseConstraint);

            // keep the mouse in sync with rendering
            render.mouse = mouse;

            // fit the render viewport to the scene
            Render.lookAt(render, {
                min: { x: 0, y: 0 },
                max: { x: 700, y: 600 }
            });

            // context for MatterTools.Demo
            return {
                engine: engine,
                runner: runner,
                render: render,
                canvas: render.canvas,
                stop: function() {
                    Matter.Render.stop(render);
                    Matter.Runner.stop(runner);
                }
            };
        };

        Example.doublePendulum.title = 'Double Pendulum';
        Example.doublePendulum.for = '>0.16.1';

        if (typeof module !== 'undefined') {
            module.exports = Example.doublePendulum;
        }

        function updatePendulum() {
            var gravityScale = parseFloat(document.getElementById('gravityScale').value);
            var stiffness = parseFloat(document.getElementById('stiffness').value);
            var angularStiffness = parseFloat(document.getElementById('angularStiffness').value);
            var armRotation = parseFloat(document.getElementById('armRotation').value);

            // Update the pendulum with the new parameters
            Example.doublePendulum().engine.gravity.scale = gravityScale;
            Example.doublePendulum().pendulum.constraints[0].stiffness = stiffness;
            Example.doublePendulum().pendulum.constraints[1].stiffness = stiffness;
            Example.doublePendulum().pendulum.constraints[0].angularStiffness = angularStiffness;
            Example.doublePendulum().pendulum.bodies[1].rotation = armRotation;
        }

        // Initialize the double pendulum example
        Example.doublePendulum();
    </script>
</body>
</html>

